# GameLife

GameLife is a full-stack application implementing Conway's classic "Game of Life", composed of a .NET (C#) backend and a React + Vite frontend. The project is fully containerized with Docker, making deployment and local development easy.

## Table of Contents
- [Problem Description](#problem-description)
- [How to Run Locally](#how-to-run-locally)
- [Design Decisions](#design-decisions)
- [Assumptions and Trade-offs](#assumptions-and-trade-offs)
- [Overview](#overview)
- [Architecture](#architecture)
- [How to Start with Docker Compose](#how-to-start-with-docker-compose)
- [Frontend](#frontend)
- [Backend](#backend)
- [API Endpoints](#api-endpoints)
- [Testing](#testing)
- [Logging, Elasticsearch and Kibana](#logging-elasticsearch-and-kibana)
- [Additional Information](#additional-information)

---

## Problem Description
GameLife is a Conway's Game of Life simulator with a modern web interface and a robust backend. The goal is to allow users to create, visualize, and manipulate boards, advancing generations and exploring the rules of the game interactively. The system must be scalable, testable, and observable (logs).

## How to Run Locally
1. **Clone the repository:**
   ```zsh
   git clone <repo-url>
   cd GameLife
   ```
2. **Backend:**
   ```zsh
   cd BackEnd/GameLifeApi
   dotnet run
   ```
   The API will be available at http://localhost:7878
3. **Frontend:**
   ```zsh
   cd FrontEnd
   npm install
   npm run dev
   ```
   The app will be available at http://localhost:8080
4. **(Optional) Elasticsearch & Kibana:**
   Use Docker Compose to run all services (see below).

## Design Decisions
- **Separation of concerns:** Backend and frontend are fully decoupled, communicating via REST.
- **Persistence:** SQLite is used for simplicity and easy local development.
- **Containerization:** Docker and Docker Compose for reproducible environments.
- **Observability:** Serilog is used for structured logging, with logs sent to Elasticsearch for analysis in Kibana.
- **Testing:** Both backend (C#) and frontend (React) have automated tests.
- **API-first:** All board operations are exposed via REST endpoints.

## Assumptions and Trade-offs
- The board size and rules follow the classic Game of Life, but can be extended.
- SQLite is used for ease of setup; for production, a more robust DB may be needed.
- Logs are sent to Elasticsearch only if the service is available; otherwise, fallback is console.
- The UI is optimized for desktop browsers.
- No authentication is implemented (for demo/learning purposes).

---

## Overview
GameLife lets you create, view, and manipulate "boards" for the Game of Life, with a modern web interface and a robust REST API. The backend manages game logic, persistence, and rules, while the frontend provides an interactive user experience.

## Architecture
- **Backend:** .NET 8, C#, ASP.NET Core, SQLite
- **Frontend:** React 19, Vite, TailwindCSS
- **Containerization:** Docker, Docker Compose

## How to Start with Docker Compose
1. Make sure you have Docker and Docker Compose installed.
2. Run the command to start the containers:
   ```zsh
   docker compose up --build
   ```
3. Access the frontend at [http://localhost:8080](http://localhost:8080) and the API documentation (Swagger) at [http://localhost:7878/swagger](http://localhost:7878/swagger).

## Frontend
- Located in `FrontEnd/`
- Interface to create boards, advance generations, pause, reset, and view the game state.
- Main technologies: React, Vite, TailwindCSS, Testing Library, Vitest
- To run locally (outside Docker):
  ```zsh
  cd FrontEnd
  npm install
  npm run dev
  ```

## Backend
- Located in `BackEnd/GameLifeApi/`
- RESTful API for board and cell manipulation.
- SQLite database for persistence.
- To run locally (outside Docker):
  ```zsh
  cd BackEnd/GameLifeApi
  dotnet run
  ```

## API Endpoints
Main available endpoints:

- `POST /boards` — Create a new board
  - Body: `{ "cells": string }`
- `GET /boards/{id}/next` — Get the next state of the board
- `GET /boards/{id}/next/{times}` — Advance multiple generations and get the state
- `GET /boards/{id}/final` — Get the final state of the board (until stabilization)
- `GET /boards/{id}/current` — Get the current state of the board

> All endpoints return JSON. IDs are UUID.

## Testing
- **Backend:** Unit tests in C# (`BackEnd/GameLifeTests/`)
- **Frontend:** Component and hook tests with Vitest and Testing Library (`FrontEnd/tests/ui/`)
- To run frontend tests:
  ```zsh
  cd FrontEnd
  npm run test
  ```
- To run backend tests:
  ```zsh
  cd BackEnd/GameLifeTests
  dotnet test
  ```

## Logging, Elasticsearch and Kibana
- **Structured logs** are generated by the backend using Serilog.
- Logs are sent to Elasticsearch if available (see `appsettings.Development.json`).
- To run Elasticsearch and Kibana locally, use Docker Compose (services `elasticsearch` and `kibana`).
- Access Kibana at [http://localhost:5601](http://localhost:5601) and create a Data View for the pattern `gamelife-logs-*` to visualize logs.
- Example log: when a board is created, a log entry is sent with the board ID and cell count.
- If logs do not appear, check backend logs for errors, ensure Elasticsearch is running, and verify the index pattern in Kibana.

## Additional Information
- The project uses separate Dockerfiles for backend and frontend.
- The database is persisted in a SQLite file (`gamelife.db`).
- The frontend communicates with the backend via REST calls.
- The code is organized in layers: Models, Repository, Services, Controllers.
- The frontend uses custom stores to manage board state.

---

## Demo
![](demonstration.gif)

## License
This project is open-source and licensed under the MIT license.
